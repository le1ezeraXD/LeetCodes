'''439.三元表达式解析器
给定一个表示任意嵌套三元表达式的字符串 expression ，求值并返回其结果。

你可以总是假设给定的表达式是有效的，并且只包含数字， '?' ，  ':' ，  'T' 和 'F' ，其中 'T' 为真， 'F' 为假。表达式中的所有数字都是 一位 数(即在 [0,9] 范围内)。

条件表达式从右到左分组(大多数语言中都是这样)，表达式的结果总是为数字 'T' 或 'F' 。

 

示例 1：

输入： expression = "T?2:3"
输出： "2"
解释： 如果条件为真，结果为 2；否则，结果为 3。
示例 2：

输入： expression = "F?1:T?4:5"
输出： "4"
解释： 条件表达式自右向左结合。使用括号的话，相当于：
 "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"
示例 3：

输入： expression = "T?T?F:5:3"
输出： "F"
解释： 条件表达式自右向左结合。使用括号的话，相当于：
"(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
"(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"
'''

class Solution:
    def parseTernary(self, expression: str) -> str:
    	#将字符串转为list方便处理
        skt = list(expression)
        #创建新的list用来存放解析后的字符串
        k = list()
        while skt:
        	#从右往左处理字符串，取最右一位
            c = skt.pop()
            #如果是?, 则说明这一阶段的表达式的两个结果已经压入k栈中，准备对结果进行处理
            if c == '?':
            	#根据字符串的下一位是T还是F做不同的处理
                if skt.pop() == 'F':
                	#如果是F，则上一位是正确结果
                	#举例: F?2:3
                	#此时k栈内应该是[3,2]
                	#应保留3，使用pop将2弹出
                    k.pop()
                else:
                	#如果是T，则上上一位是正确结果
                	#举例: T?2:3
                	#此时栈内为[3,2]
                	#先pop出正确答案2，用变量保存
                    sm = k.pop()
                    #然后弹出不需要的3
                    k.pop()
                    #再将正确结果压入k栈内
                    k.append(sm)
            #如果不是?且不是:，则一定是两个结果中的某一个
            #压入k栈中
            elif c != ':':
                k.append(c)
        #返回k栈中第一个元素即为结果
        return k[0]
